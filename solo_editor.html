<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yu-Gi-Oh! Master Duel Solo Mode Editor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f0f0f0;
        }
        .tab-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            background: #ddd;
            border: none;
            cursor: pointer;
            border-radius: 5px;
        }
        .tab.active {
            background: #007bff;
            color: white;
        }
        .content {
            background: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .section {
            display: none;
        }
        .section.active {
            display: block;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input, select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        button {
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #218838;
        }
        .gate-list, .chapter-list {
            margin-top: 20px;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 4px;
        }
        .gate-item, .chapter-item {
            background: #f8f9fa;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
        }
        .npc-info {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }
        .help-text {
            font-size: 0.85em;
            color: #666;
            margin-top: 2px;
        }
        .deck-editor {
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .card-preview {
            width: 250px;
            display: flex;
            flex-direction: column;
            border: 1px solid #333;
            border-radius: 8px;
            overflow: hidden;
            background: #1a1a1a;
        }
        .card-preview img {
            width: 100%;
            height: 365px;
            object-fit: contain;
        }
        .card-info {
            padding: 10px;
            color: white;
            background: #1a1a1a;
            border-top: 1px solid #333;
        }
        .card-info .card-name {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 4px;
        }
        .card-info .card-type {
            color: #aaa;
            font-size: 0.9em;
            margin-bottom: 8px;
        }
        .card-info .card-stats,
        .card-info .card-level {
            color: #ddd;
            font-size: 0.9em;
            margin-bottom: 4px;
            padding: 2px 4px;
            background: #222;
            border-radius: 3px;
            display: inline-block;
        }
        .card-info .card-desc {
            font-size: 0.85em;
            line-height: 1.4;
            max-height: 150px;
            overflow-y: auto;
            padding-right: 5px;
            margin-top: 8px;
            color: #ddd;
        }
        .card-info .card-desc::-webkit-scrollbar {
            width: 6px;
        }
        .card-info .card-desc::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        .card-info .card-desc::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 3px;
        }
        .deck-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .deck-section {
            border: 1px solid #333;
            border-radius: 8px;
            background: #1a1a1a;
            padding: 10px;
        }
        .deck-section h3 {
            color: white;
            margin: 0 0 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .deck-count {
            font-size: 0.9em;
            color: #aaa;
        }
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 5px;
            padding: 5px;
        }
        .card-item {
            position: relative;
            width: 60px;
            height: 87px;
            border: 1px solid #444;
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
            background: #222;
        }
        .card-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .card-item:hover {
            border-color: #007bff;
        }
        .card-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 0.8em;
        }
        .search-section {
            margin-bottom: 20px;
        }
        .search-container {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .search-input {
            flex: 1;
            padding: 8px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #1a1a1a;
            color: white;
        }
        .search-results {
            height: 200px;
            overflow-y: auto;
            border: 1px solid #333;
            border-radius: 4px;
            background: #1a1a1a;
            padding: 5px;
        }
        .result-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
            cursor: pointer;
            border-bottom: 1px solid #333;
        }
        .result-item:hover {
            background: #2a2a2a;
        }
        .result-item img {
            width: 40px;
            height: 58px;
            object-fit: cover;
            border-radius: 3px;
        }
        .result-info {
            flex: 1;
        }
        .result-name {
            color: white;
            font-weight: bold;
        }
        .result-type {
            color: #aaa;
            font-size: 0.9em;
        }
        .error {
            color: red;
            margin-top: 5px;
        }
        .status-bar {
            background: #f8f9fa;
            padding: 10px;
            margin-bottom: 20px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .status-item {
            display: inline-block;
            margin-right: 20px;
        }
        .status-item.loaded {
            color: #28a745;
        }
        .status-item.error {
            color: #dc3545;
        }
        .file-browser {
            margin-top: 20px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .file-item {
            padding: 5px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }
        .file-item:hover {
            background: #e9ecef;
        }
        .deck-toggle {
            display: flex;
            gap: 10px;
        }
        .toggle-btn {
            flex: 1;
            padding: 10px;
            background: #333;
            color: white;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
        }
        .toggle-btn.active {
            background: #007bff;
            border-color: #0056b3;
        }
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-size: 1.2em;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <h1>Yu-Gi-Oh! Master Duel Solo Mode Editor</h1>
    
    <div class="status-bar">
        <div class="status-item" id="soloStatus">Solo.json: Not Loaded</div>
        <div class="status-item" id="npcStatus">SoloNpcDeckIds.json: Not Loaded</div>
        <div class="status-item" id="cardStatus">CardList.json: Not Loaded</div>
        <div class="status-item" id="workingDir">Working Directory: Loading...</div>
    </div>
    
    <div class="tab-container">
        <button class="tab active" onclick="showSection('files')">Files</button>
        <button class="tab" onclick="showSection('gates')">Gates</button>
        <button class="tab" onclick="showSection('chapters')">Chapters</button>
        <button class="tab" onclick="showSection('unlocks')">Unlocks</button>
        <button class="tab" onclick="showSection('duels')">Solo Duels</button>
        <button class="tab" onclick="showSection('movies')">Movies</button>
        <button class="tab" onclick="showSection('duelJson')">Deck Editor</button>
    </div>

    <div class="content">
        <!-- Files Section -->
        <div id="files" class="section active">
            <h2>File Browser</h2>
            <div class="form-group">
                <label>Working Directory:</label>
                <input type="text" id="workingDirInput" readonly>
                <button onclick="reloadFiles()">Reload Files</button>
            </div>
            <div class="file-browser">
                <h3>Core Files:</h3>
                <div id="coreFiles" class="file-list"></div>
                <h3>Solo Duels:</h3>
                <div id="duelFiles" class="file-list"></div>
            </div>
        </div>

        <!-- Gates Section -->
        <div id="gates" class="section active">
            <h2>Gate Editor</h2>
            <div class="form-group">
                <label>Gate ID:</label>
                <input type="number" id="gateId" min="1">
                <div class="help-text">Unique identifier for the gate</div>
            </div>
            <div class="form-group">
                <label>Priority:</label>
                <input type="number" id="priority" min="1">
                <div class="help-text">Display order in the gate list (lower numbers appear first)</div>
            </div>
            <div class="form-group">
                <label>Parent Gate:</label>
                <input type="number" id="parentGate" min="0">
                <div class="help-text">ID of the parent gate (0 for no parent)</div>
            </div>
            <div class="form-group">
                <label>Unlock ID:</label>
                <input type="number" id="unlockId" min="0">
                <div class="help-text">ID for unlock requirements</div>
            </div>
            <div class="form-group">
                <label>View Gate:</label>
                <input type="number" id="viewGate" min="0">
            </div>
            <div class="form-group">
                <label>Clear Chapter:</label>
                <input type="number" id="clearChapter" min="0">
                <div class="help-text">Chapter that needs to be cleared</div>
            </div>
            <div class="form-group">
                <label>Category:</label>
                <select id="category">
                    <option value="1">Story Gate</option>
                    <option value="2">Practice Gate</option>
                </select>
            </div>
            <button onclick="addGate()">Add/Update Gate</button>

            <div class="gate-list" id="gateList">
                <!-- Gates will be listed here -->
            </div>
        </div>

        <!-- Chapters Section -->
        <div id="chapters" class="section">
            <h2>Chapter Editor</h2>
            <div class="form-group">
                <label>Gate ID:</label>
                <input type="number" id="chapterGateId" min="1">
                <div class="help-text">ID of the gate this chapter belongs to</div>
            </div>
            <div class="form-group">
                <label>Chapter ID:</label>
                <input type="number" id="chapterId" min="1">
                <div class="help-text">Unique identifier for the chapter</div>
            </div>
            <div class="form-group">
                <label>Parent Chapter:</label>
                <input type="number" id="parentChapter" min="0">
                <div class="help-text">ID of the parent chapter (0 for no parent)</div>
            </div>
            <div class="form-group">
                <label>Difficulty:</label>
                <select id="difficulty">
                    <option value="0">Story</option>
                    <option value="1">Easy</option>
                    <option value="2">Normal</option>
                    <option value="3">Hard</option>
                    <option value="4">Very Hard</option>
                    <option value="5">Challenge</option>
                </select>
            </div>
            <div class="form-group">
                <label>Mydeck Set ID:</label>
                <input type="number" id="mydeckSetId" min="0">
                <div class="help-text">Deck ID for player's loaner deck (0 for using own deck)</div>
            </div>
            <div class="form-group">
                <label>Set ID:</label>
                <input type="number" id="setId" min="0">
                <div class="help-text">Deck ID for opponent's deck</div>
            </div>
            <div class="form-group">
                <label>NPC ID:</label>
                <select id="npcId" onchange="updateNpcInfo()">
                    <option value="0">Select NPC</option>
                </select>
                <div id="npcInfo" class="npc-info"></div>
            </div>
            <div class="form-group">
                <label>
                    <input type="checkbox" id="isMovie" onchange="toggleMovieFields()">
                    Is Movie Chapter
                </label>
                <div class="help-text">Check this if this chapter plays a video instead of a duel</div>
            </div>
            <button onclick="addChapter()">Add/Update Chapter</button>

            <div class="chapter-list" id="chapterList">
                <!-- Chapters will be listed here -->
            </div>
        </div>

        <!-- Unlocks Section -->
        <div id="unlocks" class="section">
            <h2>Unlock Editor</h2>
            <div class="form-group">
                <label>Unlock ID:</label>
                <input type="number" id="unlockEntryId" min="1">
                <div class="help-text">Unique identifier for the unlock requirement</div>
            </div>
            <div class="form-group">
                <label>Required Chapter:</label>
                <input type="number" id="requiredChapter" min="1">
                <div class="help-text">Chapter that needs to be completed to unlock</div>
            </div>
            <button onclick="addUnlock()">Add/Update Unlock</button>

            <div class="unlock-list" id="unlockList">
                <!-- Unlocks will be listed here -->
            </div>
        </div>

        <!-- Solo Duels Section -->
        <div id="duels" class="section">
            <h2>Solo Duel Editor</h2>
            
            <!-- Player Settings -->
            <div style="background: #f8f9fa; padding: 15px; border-radius: 4px; margin-bottom: 20px;">
                <h3>Player Settings</h3>
                <div class="form-group">
                    <label>Player Name:</label>
                    <input type="text" id="playerName" value="Name">
                    <div class="help-text">Name of the player character</div>
                </div>
                <div class="form-group">
                    <label>Player Icon:</label>
                    <select id="playerIcon">
                        <!-- Will be populated with ICON items -->
                    </select>
                </div>
                <div class="form-group">
                    <label>Player Icon Frame:</label>
                    <select id="playerIconFrame">
                        <!-- Will be populated with ICON_FRAME items -->
                    </select>
                </div>
                <div class="form-group">
                    <label>Player Sleeve:</label>
                    <select id="playerSleeve">
                        <!-- Will be populated with PROTECTOR items -->
                    </select>
                </div>
                <div class="form-group">
                    <label>Player Field:</label>
                    <select id="playerField">
                        <!-- Will be populated with FIELD items -->
                    </select>
                </div>
            </div>

            <!-- CPU Settings -->
            <div style="background: #f8f9fa; padding: 15px; border-radius: 4px; margin-bottom: 20px;">
                <h3>CPU Settings</h3>
                <div class="form-group">
                    <label>CPU Name:</label>
                    <input type="text" id="cpuName" value="CPU Opponent">
                    <div class="help-text">Name of the CPU opponent</div>
                </div>
                <div class="form-group">
                    <label>CPU Icon:</label>
                    <select id="cpuIcon">
                        <!-- Will be populated with ICON items -->
                    </select>
                </div>
                <div class="form-group">
                    <label>CPU Icon Frame:</label>
                    <select id="cpuIconFrame">
                        <!-- Will be populated with ICON_FRAME items -->
                    </select>
                </div>
                <div class="form-group">
                    <label>CPU Sleeve:</label>
                    <select id="cpuSleeve">
                        <!-- Will be populated with PROTECTOR items -->
                    </select>
                </div>
                <div class="form-group">
                    <label>CPU Field:</label>
                    <select id="cpuField">
                        <!-- Will be populated with FIELD items -->
                    </select>
                </div>
            </div>

            <!-- Existing duel settings -->
            <div class="form-group">
                <label>Chapter ID:</label>
                <input type="number" id="duelChapterId" min="1">
                <div class="help-text">The chapter this duel belongs to</div>
            </div>
            <div class="form-group">
                <label>First Player:</label>
                <select id="firstPlayer">
                    <option value="1">Player</option>
                    <option value="2">CPU</option>
                </select>
            </div>
            <div class="form-group">
                <label>Life Points:</label>
                <input type="number" id="lifePoints" min="100" max="99999" value="8000" onchange="validateLifePoints(this)">
                <div class="help-text">Starting life points for both players (100-99999)</div>
            </div>
            <div class="form-group">
                <label>CPU Level:</label>
                <select id="cpuLevel">
                    <option value="100">Normal</option>
                    <option value="200">Hard</option>
                    <option value="300">Very Hard</option>
                </select>
            </div>
            <div class="form-group">
                <label>CPU Flag:</label>
                <select id="cpuFlag">
                    <option value="AttackOnly">Attack Only</option>
                    <option value="Normal">Normal</option>
                    <option value="Defense">Defense Priority</option>
                </select>
            </div>
            <div class="form-group">
                <label>Story Deck ID (Player):</label>
                <input type="number" id="storyDeckId1" min="0">
                <div class="help-text">Loaner deck ID for player (0 for using own deck)</div>
            </div>
            <div class="form-group">
                <label>Story Deck ID (CPU):</label>
                <input type="number" id="storyDeckId2" min="0">
                <div class="help-text">Deck ID for CPU opponent</div>
            </div>
            <div class="form-group">
                <label>BGM:</label>
                <select id="bgmSelect">
                    <option value="BGM_DUEL_NORMAL_01">Normal 1</option>
                    <option value="BGM_DUEL_NORMAL_02">Normal 2</option>
                    <option value="BGM_DUEL_NORMAL_03">Normal 3</option>
                    <option value="BGM_DUEL_KEYCARD_01">Key Card 1</option>
                    <option value="BGM_DUEL_KEYCARD_02">Key Card 2</option>
                    <option value="BGM_DUEL_KEYCARD_03">Key Card 3</option>
                    <option value="BGM_DUEL_CLIMAX_01">Climax 1</option>
                    <option value="BGM_DUEL_CLIMAX_02">Climax 2</option>
                    <option value="BGM_DUEL_CLIMAX_03">Climax 3</option>
                </select>
            </div>
            <div class="form-group">
                <label>No Shuffle:</label>
                <select id="noShuffle">
                    <option value="true">Yes (Fixed Starting Hand)</option>
                    <option value="false">No (Random Starting Hand)</option>
                </select>
                <div class="help-text">Whether the starting hand should be fixed or random</div>
            </div>
            <button onclick="saveDuel()">Save Duel Settings</button>

            <div class="duel-list" id="duelList">
                <!-- Duels will be listed here -->
            </div>
        </div>

        <!-- Movies Section -->
        <div id="movies" class="section">
            <h2>Movie Editor</h2>
            <div class="form-group">
                <label>Chapter ID:</label>
                <select id="movieChapter" onchange="loadMovie()">
                    <option value="">Select Chapter</option>
                </select>
            </div>
            <div class="form-group">
                <label>Remote URL:</label>
                <input type="text" id="movieUrl" placeholder="Enter video URL">
                <div class="help-text">URL of the video file to play</div>
            </div>
            <div class="form-group">
                <label>Bitrate Value:</label>
                <input type="text" id="movieBv" value="0.800000">
                <div class="help-text">Video bitrate value (default: 0.800000)</div>
            </div>
            <div class="form-group">
                <label>Display Size:</label>
                <input type="text" id="movieDs" placeholder="e.g., 100.08MB">
                <div class="help-text">Display size of the video</div>
            </div>
            <div class="form-group">
                <label>Play Time (ms):</label>
                <input type="number" id="moviePt" placeholder="Duration in milliseconds">
                <div class="help-text">Duration of the video in milliseconds</div>
            </div>
            <button onclick="saveMovie()">Save Movie Settings</button>

            <div class="movie-list" id="movieList">
                <!-- Movies will be listed here -->
            </div>
        </div>

        <!-- Duel JSON Section -->
        <div id="duelJson" class="section">
            <h2>Deck Editor</h2>
            <div class="form-group">
                <label>Chapter ID:</label>
                <select id="duelJsonChapter" onchange="loadDuelJson()">
                    <option value="">Select Chapter</option>
                </select>
            </div>

            <div class="deck-editor">
                <div class="card-preview">
                    <!-- Card preview will be shown here -->
                </div>

                <div class="deck-container">
                    <div class="deck-toggle" style="margin-bottom: 10px;">
                        <button id="playerToggle" class="toggle-btn active" onclick="toggleDeck('player')">Player Deck</button>
                        <button id="cpuToggle" class="toggle-btn" onclick="toggleDeck('cpu')">CPU Deck</button>
                    </div>

                    <div class="search-section">
                        <div class="search-container">
                            <input type="text" class="search-input" id="cardSearch" placeholder="Search cards..." oninput="searchCards()">
                        </div>
                        <div class="search-results" id="searchResults">
                            <!-- Search results will be shown here -->
                        </div>
                    </div>

                    <div class="deck-section">
                        <h3>Main Deck <span class="deck-count" id="mainCount">0 cards</span></h3>
                        <div class="card-grid" id="mainDeck"></div>
                    </div>

                    <div class="deck-section">
                        <h3>Extra Deck <span class="deck-count" id="extraCount">0 cards</span></h3>
                        <div class="card-grid" id="extraDeck"></div>
                    </div>

                    <div class="deck-section">
                        <h3>Side Deck <span class="deck-count" id="sideCount">0 cards</span></h3>
                        <div class="card-grid" id="sideDeck"></div>
                    </div>
                </div>
            </div>

            <textarea id="jsonEditor" class="json-editor" spellcheck="false"></textarea>
            <div id="jsonError" class="error"></div>
            <button onclick="saveDuelJson()">Save Duel JSON</button>
        </div>
    </div>

    <div id="loadingIndicator" class="loading" style="display: none;">
        <div class="loading-spinner"></div>
        <div>Loading...</div>
    </div>

    <script>
        let soloData = null;
        let npcDeckIds = null;
        let soloDuels = {};
        let cardDatabase = null;
        let ydkMapping = {}; // Mapping between Konami IDs and game IDs
        let currentDuelJson = null;
        let workingDirectory = '';
        let loadedFiles = {
            solo: false,
            npc: false,
            cards: false,
            ydk: false
        };
        let currentDeckType = 'player'; // Add this variable to track current deck type
        let movieFiles = {};
        let itemData = null;

        async function loadYdkMapping() {
            try {
                const response = await fetch(`${workingDirectory}/YdkIds.txt`);
                if (!response.ok) throw new Error('Failed to load YdkIds.txt');
                const text = await response.text();
                
                // Parse the mapping file
                text.split('\n').forEach(line => {
                    const [konamiId, gameId] = line.trim().split(' ');
                    if (konamiId && gameId) {
                        ydkMapping[gameId] = konamiId;
                    }
                });
                
                loadedFiles.ydk = true;
                console.log('YdkIds mapping loaded');
                
                // Now load card data from YGOPRODeck API
                await loadCardDatabase();
            } catch (error) {
                console.error('Error loading YdkIds:', error);
                document.getElementById('cardStatus').className = 'status-item error';
                document.getElementById('cardStatus').textContent = 'Card Database: Error - Failed to load YdkIds';
            }
        }

        async function loadCardDatabase() {
            try {
                const response = await fetch('https://db.ygoprodeck.com/api/v7/cardinfo.php');
                if (!response.ok) throw new Error('Failed to load card database');
                const data = await response.json();
                
                // Create a mapping of Konami IDs to card data
                cardDatabase = {};
                data.data.forEach(card => {
                    cardDatabase[card.id] = card;
                });
                
                loadedFiles.cards = true;
                document.getElementById('cardStatus').className = 'status-item loaded';
                document.getElementById('cardStatus').textContent = 'Card Database: Loaded';
                console.log('Card database loaded');
            } catch (error) {
                console.error('Error loading card database:', error);
                document.getElementById('cardStatus').className = 'status-item error';
                document.getElementById('cardStatus').textContent = 'Card Database: Error - ' + error.message;
            }
        }

        function getCardInfo(gameId) {
            const konamiId = ydkMapping[gameId];
            if (!konamiId) return null;
            return cardDatabase[konamiId] || null;
        }

        function getCardName(gameId) {
            const cardInfo = getCardInfo(gameId);
            if (!cardInfo) return `Unknown Card (${gameId})`;
            return `${cardInfo.name} (${gameId})`;
        }

        async function initializeEditor() {
            try {
                showLoading('Initializing editor...');
                // Set working directory first
                workingDirectory = 'http://localhost:8000';
                document.getElementById('workingDir').textContent = `Working Directory: ${workingDirectory}`;
                document.getElementById('workingDirInput').value = workingDirectory;

                console.log('Loading ItemID.json first...');
                await loadItemData();  // Load ItemID.json before anything else

                console.log('Loading YdkIds and card database...');
                await loadYdkMapping();

                console.log('Loading game files...');
                const [soloResponse, npcResponse] = await Promise.all([
                    fetch(workingDirectory + '/Solo.json')
                        .then(response => {
                            if (!response.ok) throw new Error(`Failed to load Solo.json: ${response.statusText}`);
                            return response.json();
                        })
                        .catch(error => {
                            console.error('Solo.json error:', error);
                            document.getElementById('soloStatus').className = 'status-item error';
                            document.getElementById('soloStatus').textContent = 'Solo.json: Error - ' + error.message;
                            throw error;
                        }),
                    fetch(workingDirectory + '/SoloNpcDeckIds.json')
                        .then(response => {
                            if (!response.ok) throw new Error(`Failed to load SoloNpcDeckIds.json: ${response.statusText}`);
                            return response.json();
                        })
                        .catch(error => {
                            console.error('SoloNpcDeckIds.json error:', error);
                            document.getElementById('npcStatus').className = 'status-item error';
                            document.getElementById('npcStatus').textContent = 'SoloNpcDeckIds.json: Error - ' + error.message;
                            throw error;
                        })
                ]);

                soloData = soloResponse;
                npcDeckIds = npcResponse;

                loadedFiles.solo = true;
                loadedFiles.npc = true;
                updateStatus();

                await loadDuelFiles();
                await loadMovieFiles();

                updateLists();
                populateNpcSelect();
                populateDuelChapterSelect();
                populateMovieChapterSelect();
                updateFileBrowser();
            } catch (error) {
                console.error('Initialization error:', error);
                alert('Error during initialization. Please check the console for details.');
            } finally {
                hideLoading();
            }
        }

        async function loadDuelFiles() {
            if (!soloData?.res?.[0]?.[1]?.[2]?.Master?.Solo?.chapter) {
                console.warn('No chapter data available');
                return;
            }

            const chapters = [];
            for (const [gateId, gate] of Object.entries(soloData.res[0][1].Master.Solo.chapter)) {
                for (const [chapterId, chapter] of Object.entries(gate)) {
                    if (chapter.npc_id > 0) {
                        chapters.push(chapterId);
                    }
                }
            }

            for (const chapterId of chapters) {
                try {
                    const response = await fetch(`${workingDirectory}/SoloDuels/${chapterId}.json`);
                    if (!response.ok) {
                        console.warn(`Could not load duel file for chapter ${chapterId}: ${response.statusText}`);
                        continue;
                    }
                    const data = await response.json();
                    soloDuels[chapterId] = data;
                } catch (error) {
                    console.warn(`Could not load duel file for chapter ${chapterId}:`, error);
                }
            }
        }

        function updateStatus() {
            document.getElementById('soloStatus').className = `status-item ${loadedFiles.solo ? 'loaded' : 'error'}`;
            document.getElementById('soloStatus').textContent = `Solo.json: ${loadedFiles.solo ? 'Loaded' : 'Error'}`;
            
            document.getElementById('npcStatus').className = `status-item ${loadedFiles.npc ? 'loaded' : 'error'}`;
            document.getElementById('npcStatus').textContent = `SoloNpcDeckIds.json: ${loadedFiles.npc ? 'Loaded' : 'Error'}`;
            
            document.getElementById('cardStatus').className = `status-item ${loadedFiles.cards ? 'loaded' : 'error'}`;
            document.getElementById('cardStatus').textContent = `CardList.json: ${loadedFiles.cards ? 'Loaded' : 'Error'}`;
        }

        function updateFileBrowser() {
            const coreFiles = document.getElementById('coreFiles');
            const duelFiles = document.getElementById('duelFiles');

            coreFiles.innerHTML = `
                <div class="file-item" onclick="viewFile('Solo.json')">Solo.json ${loadedFiles.solo ? '✓' : '✗'}</div>
                <div class="file-item" onclick="viewFile('SoloNpcDeckIds.json')">SoloNpcDeckIds.json ${loadedFiles.npc ? '✓' : '✗'}</div>
                <div class="file-item" onclick="viewFile('CardList.json')">CardList.json ${loadedFiles.cards ? '✓' : '✗'}</div>
            `;

            duelFiles.innerHTML = '';
            Object.keys(soloDuels).sort((a, b) => parseInt(a) - parseInt(b)).forEach(chapterId => {
                duelFiles.innerHTML += `
                    <div class="file-item" onclick="viewFile('SoloDuels/${chapterId}.json')">
                        ${chapterId}.json ✓
                    </div>
                `;
            });
        }

        async function viewFile(path) {
            try {
                const response = await fetch(`${workingDirectory}/${path}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                document.getElementById('jsonEditor').value = JSON.stringify(data, null, 2);
                showSection('duelJson');
            } catch (error) {
                alert(`Error loading file ${path}: ${error.message}`);
            }
        }

        function reloadFiles() {
            loadedFiles = { solo: false, npc: false, cards: false };
            soloDuels = {};
            updateStatus();
            initializeEditor();
        }

        function populateNpcSelect() {
            const npcSelect = document.getElementById('npcId');
            npcSelect.innerHTML = '<option value="0">Select NPC</option>';
            
            const uniqueNpcIds = new Set(Object.values(npcDeckIds));
            
            const sortedNpcIds = Array.from(uniqueNpcIds).sort((a, b) => a - b);
            
            sortedNpcIds.forEach(npcId => {
                const option = document.createElement('option');
                option.value = npcId;
                option.textContent = `NPC ${npcId}`;
                npcSelect.appendChild(option);
            });
        }

        function populateDuelChapterSelect() {
            const select = document.getElementById('duelJsonChapter');
            select.innerHTML = '<option value="">Select Chapter</option>';
            
            const chapters = [];
            for (const [gateId, gate] of Object.entries(soloData.res[0][1].Master.Solo.chapter)) {
                for (const [chapterId, chapter] of Object.entries(gate)) {
                    if (chapter.npc_id > 0) {
                        chapters.push(chapterId);
                    }
                }
            }

            chapters.sort((a, b) => parseInt(a) - parseInt(b));
            
            chapters.forEach(chapterId => {
                const option = document.createElement('option');
                option.value = chapterId;
                option.textContent = `Chapter ${chapterId}`;
                select.appendChild(option);
            });
        }

        function populateMovieChapterSelect() {
            const select = document.getElementById('movieChapter');
            select.innerHTML = '<option value="">Select Chapter</option>';
            
            const chapters = [];
            for (const [gateId, gate] of Object.entries(soloData.res[0][1].Master.Solo.chapter)) {
                for (const [chapterId, chapter] of Object.entries(gate)) {
                    if (chapter.anime === 1) {
                        chapters.push(chapterId);
                    }
                }
            }

            chapters.sort((a, b) => parseInt(a) - parseInt(b));
            
            chapters.forEach(chapterId => {
                const option = document.createElement('option');
                option.value = chapterId;
                option.textContent = `Chapter ${chapterId}`;
                select.appendChild(option);
            });
        }

        function updateNpcInfo() {
            const npcId = document.getElementById('npcId').value;
            const npcInfo = document.getElementById('npcInfo');
            
            if (npcId === "0") {
                npcInfo.textContent = "";
                return;
            }

            const chapterIds = Object.entries(npcDeckIds)
                .filter(([_, id]) => id === parseInt(npcId))
                .map(([chapterId, _]) => chapterId);

            npcInfo.textContent = `This NPC appears in chapter(s): ${chapterIds.join(', ')}`;
        }

        function showSection(sectionId) {
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.getElementById(sectionId).classList.add('active');
            event.target.classList.add('active');
        }

        function addGate() {
            const gateId = document.getElementById('gateId').value;
            const gate = {
                priority: parseInt(document.getElementById('priority').value),
                parent_gate: parseInt(document.getElementById('parentGate').value),
                unlock_id: parseInt(document.getElementById('unlockId').value),
                view_gate: parseInt(document.getElementById('viewGate').value),
                clear_chapter: parseInt(document.getElementById('clearChapter').value),
                category: parseInt(document.getElementById('category').value),
                open_date: -2208988800
            };

            if (!soloData.code) {
                soloData = {
                    code: 0,
                    res: [[0, { Master: { Solo: { gate: {}, chapter: {}, unlock: {} } } }]]
                };
            }

            soloData.res[0][1].Master.Solo.gate[gateId] = gate;
            updateLists();
            saveData();
        }

        function addChapter() {
            const gateId = document.getElementById('chapterGateId').value;
            const chapterId = document.getElementById('chapterId').value;
            const isMovie = document.getElementById('isMovie').checked;
            
            const chapter = {
                parent_chapter: parseInt(document.getElementById('parentChapter').value),
                difficulty: parseInt(document.getElementById('difficulty').value),
                mydeck_set_id: isMovie ? 0 : parseInt(document.getElementById('mydeckSetId').value),
                set_id: parseInt(document.getElementById('setId').value),
                unlock_id: 0,
                begin_sn: isMovie ? `Sr00${chapterId}` : "",
                npc_id: isMovie ? 0 : parseInt(document.getElementById('npcId').value),
                anime: isMovie ? 1 : 0
            };

            if (!soloData.res[0][1].Master.Solo.chapter[gateId]) {
                soloData.res[0][1].Master.Solo.chapter[gateId] = {};
            }
            soloData.res[0][1].Master.Solo.chapter[gateId][chapterId] = chapter;
            updateLists();
            saveData();
        }

        function addUnlock() {
            const unlockId = document.getElementById('unlockEntryId').value;
            const requiredChapter = document.getElementById('requiredChapter').value;
            
            if (!soloData.res[0][1].Master.Solo.unlock[unlockId]) {
                soloData.res[0][1].Master.Solo.unlock[unlockId] = {};
            }
            
            soloData.res[0][1].Master.Solo.unlock[unlockId] = {
                "2": [parseInt(requiredChapter)]
            };
            
            updateLists();
            saveData();
        }

        function updateLists() {
            const gateList = document.getElementById('gateList');
            gateList.innerHTML = '';
            const gates = soloData.res[0][1].Master.Solo.gate;
            for (const [id, gate] of Object.entries(gates)) {
                const gateElement = document.createElement('div');
                gateElement.className = 'gate-item';
                gateElement.innerHTML = `
                    Gate ${id}: Priority ${gate.priority}, Category ${gate.category === 1 ? 'Story' : 'Practice'}
                    <button onclick="editGate(${id})">Edit</button>
                    <button onclick="deleteGate(${id})">Delete</button>
                `;
                gateList.appendChild(gateElement);
            }

            const chapterList = document.getElementById('chapterList');
            chapterList.innerHTML = '';
            const chapters = soloData.res[0][1].Master.Solo.chapter;
            for (const [gateId, gateChapters] of Object.entries(chapters)) {
                for (const [chapterId, chapter] of Object.entries(gateChapters)) {
                    const chapterElement = document.createElement('div');
                    chapterElement.className = 'chapter-item';
                    if (chapter.anime === 1) {
                        chapterElement.innerHTML = `
                            Gate ${gateId}, Chapter ${chapterId}: Movie Chapter
                            <div class="help-text">Scene ID: ${chapter.begin_sn}</div>
                            <button onclick="editChapter(${gateId}, ${chapterId})">Edit</button>
                            <button onclick="deleteChapter(${gateId}, ${chapterId})">Delete</button>
                        `;
                    } else {
                        const difficultyNames = ['Story', 'Easy', 'Normal', 'Hard', 'Very Hard', 'Challenge'];
                        chapterElement.innerHTML = `
                            Gate ${gateId}, Chapter ${chapterId}: ${difficultyNames[chapter.difficulty]} (NPC ${chapter.npc_id})
                            <button onclick="editChapter(${gateId}, ${chapterId})">Edit</button>
                            <button onclick="deleteChapter(${gateId}, ${chapterId})">Delete</button>
                        `;
                    }
                    chapterList.appendChild(chapterElement);
                }
            }

            const unlockList = document.getElementById('unlockList');
            unlockList.innerHTML = '';
            const unlocks = soloData.res[0][1].Master.Solo.unlock;
            for (const [id, unlock] of Object.entries(unlocks)) {
                const unlockElement = document.createElement('div');
                unlockElement.className = 'gate-item';
                unlockElement.innerHTML = `
                    Unlock ${id}: Requires ${unlock[2] ? unlock[2].join(', ') : 'None'}
                    <button onclick="deleteUnlock(${id})">Delete</button>
                `;
                unlockList.appendChild(unlockElement);
            }

            updateDuelsList();
        }

        function editGate(id) {
            const gate = soloData.res[0][1].Master.Solo.gate[id];
            document.getElementById('gateId').value = id;
            document.getElementById('priority').value = gate.priority;
            document.getElementById('parentGate').value = gate.parent_gate;
            document.getElementById('unlockId').value = gate.unlock_id;
            document.getElementById('viewGate').value = gate.view_gate;
            document.getElementById('clearChapter').value = gate.clear_chapter;
            document.getElementById('category').value = gate.category;
        }

        function editChapter(gateId, chapterId) {
            const chapter = soloData.res[0][1].Master.Solo.chapter[gateId][chapterId];
            document.getElementById('chapterGateId').value = gateId;
            document.getElementById('chapterId').value = chapterId;
            document.getElementById('parentChapter').value = chapter.parent_chapter;
            document.getElementById('difficulty').value = chapter.difficulty;
            document.getElementById('mydeckSetId').value = chapter.mydeck_set_id;
            document.getElementById('setId').value = chapter.set_id;
            document.getElementById('npcId').value = chapter.npc_id;
            updateNpcInfo();
        }

        function deleteGate(id) {
            if (!confirm(`Are you sure you want to delete Gate ${id}? This action cannot be undone.`)) {
                return;
            }
            delete soloData.res[0][1].Master.Solo.gate[id];
            updateLists();
            saveData();
        }

        function deleteChapter(gateId, chapterId) {
            if (!confirm(`Are you sure you want to delete Chapter ${chapterId} from Gate ${gateId}? This action cannot be undone.`)) {
                return;
            }
            delete soloData.res[0][1].Master.Solo.chapter[gateId][chapterId];
            if (Object.keys(soloData.res[0][1].Master.Solo.chapter[gateId]).length === 0) {
                delete soloData.res[0][1].Master.Solo.chapter[gateId];
            }
            updateLists();
            saveData();
        }

        function deleteUnlock(id) {
            if (!confirm(`Are you sure you want to delete Unlock ${id}? This action cannot be undone.`)) {
                return;
            }
            delete soloData.res[0][1].Master.Solo.unlock[id];
            updateLists();
            saveData();
        }

        function saveData() {
            const dataStr = JSON.stringify(soloData, null, 2);
            const blob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'Solo.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function saveDuel() {
            const chapterId = document.getElementById('duelChapterId').value;
            const duelString = generateRandomDuelString();
            const duelData = {
                "code": 0,
                "res": [[79, {
                    "Duel": {
                        "dlginfo": true,
                        "RandSeed": Math.floor(Math.random() * 1000000000),
                        "MyID": 0,
                        "MyType": 0,
                        "FirstPlayer": parseInt(document.getElementById('firstPlayer').value),
                        "Type": 0,
                        "Limit": 0,
                        "GameMode": 9,
                        "cpu": parseInt(document.getElementById('cpuLevel').value),
                        "cpuflag": document.getElementById('cpuFlag').value,
                        "reg": [0, 0],
                        "mat": [
                            parseInt(document.getElementById('playerField').value),
                            parseInt(document.getElementById('cpuField').value)
                        ],
                        "sleeve": [
                            parseInt(document.getElementById('playerSleeve').value),
                            parseInt(document.getElementById('cpuSleeve').value)
                        ],
                        "icon": [
                            parseInt(document.getElementById('playerIcon').value),
                            parseInt(document.getElementById('cpuIcon').value)
                        ],
                        "icon_frame": [
                            parseInt(document.getElementById('playerIconFrame').value),
                            parseInt(document.getElementById('cpuIconFrame').value)
                        ],
                        "avatar": [0, 0],
                        "avatar_home": [0, 0],
                        "duel_object": [1100001, 1100001],
                        "level": [0, 0],
                        "wallpaper": [1130001, 1130001],
                        "profile_tag": [[1020001], [1020001]],
                        "follow_num": [0, 0],
                        "follower_num": [0, 0],
                        "pcode": [0, 0],
                        "name": [
                            document.getElementById('playerName').value,
                            document.getElementById('cpuName').value
                        ],
                        "rank": [1, 0],
                        "DuelistLv": [0, 0],
                        "Deck": [
                            {
                                "Main": { "CardIds": [], "Rare": [] },
                                "Extra": { "CardIds": [], "Rare": [] },
                                "Side": { "CardIds": [], "Rare": [] }
                            },
                            {
                                "Main": { "CardIds": [], "Rare": [] },
                                "Extra": { "CardIds": [], "Rare": [] },
                                "Side": { "CardIds": [], "Rare": [] }
                            }
                        ],
                        "LeftTimeMax": 0,
                        "TurnTimeMax": 0,
                        "TotalTimeMax": 1000,
                        "auto": -1,
                        "rec": false,
                        "recf": false,
                        "bgms": [
                            document.getElementById('bgmSelect').value,
                            document.getElementById('bgmSelect').value.replace('NORMAL', 'KEYCARD'),
                            document.getElementById('bgmSelect').value.replace('NORMAL', 'CLIMAX')
                        ],
                        "tag": false,
                        "MyPartnerType": 1,
                        "PlayableTagPartner": 0,
                        "regulation_id": 0,
                        "duel_start_timestamp": Math.floor(Date.now() / 1000),
                        "surrender": true,
                        "story_deck_id": [
                            parseInt(document.getElementById('storyDeckId1').value),
                            parseInt(document.getElementById('storyDeckId2').value)
                        ],
                        "chapter": parseInt(chapterId),
                        "life": [parseInt(document.getElementById('lifePoints').value), parseInt(document.getElementById('lifePoints').value)],
                        "noshuffle": document.getElementById('noShuffle').value === 'true',
                        "hnum": [5, 5],
                        "did": generateRandomDid(),
                        "duel": duelString,
                        "is_pvp": false
                    },
                    "Persistence": {
                        "System": {
                            "duel": duelString
                        }
                    }
                }, 0, 0]],
                "remove": ["Duel", "DuelResult", "Result"]
            };

            // If we have current deck data, use it
            if (currentDuelJson?.res?.[0]?.[1]?.Duel?.Deck) {
                duelData.res[0][1].Duel.Deck = currentDuelJson.res[0][1].Duel.Deck;
            }

            const dataStr = JSON.stringify(duelData, null, 2);
            const blob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${chapterId}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Helper function to generate random duel string
        function generateRandomDuelString() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
            let result = '';
            for (let i = 0; i < 64; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        // Helper function to generate random did (duel ID)
        function generateRandomDid() {
            // Generate a random 64-bit integer
            const high = Math.floor(Math.random() * 0x100000000) >>> 0;
            const low = Math.floor(Math.random() * 0x100000000) >>> 0;
            return high * 0x100000000 + low;
        }

        async function loadDuel(chapterId) {
            try {
                showLoading("Loading duel settings...");
                const response = await fetch(`${workingDirectory}/SoloDuels/${chapterId}.json`);
                if (!response.ok) {
                    throw new Error(`Failed to load duel: ${response.statusText}`);
                }
                const data = await response.json();
                
                // Store the entire JSON for later use
                currentDuelJson = data;
                
                // Validate the data structure
                if (!data?.res?.[0]?.[1]?.Duel) {
                    throw new Error('Invalid duel data structure');
                }
                
                const duel = data.res[0][1].Duel;
                
                // Update form fields with duel data, with null checks
                document.getElementById('duelChapterId').value = duel.chapter || '';
                document.getElementById('firstPlayer').value = duel.FirstPlayer || 1;
                document.getElementById('cpuLevel').value = duel.cpu || 100;
                document.getElementById('cpuFlag').value = duel.cpuflag || 'Normal';
                
                // Handle arrays with default values if undefined
                const mat = duel.mat || [1090001, 1090001];
                const sleeve = duel.sleeve || [1070001, 1070001];
                const icon = duel.icon || [1010014, 1010001];
                const icon_frame = duel.icon_frame || [1030001, 1030001];
                const name = duel.name || ['Player', 'CPU'];
                const story_deck_id = duel.story_deck_id || [0, 0];
                const life = duel.life || [8000, 8000];
                
                document.getElementById('playerField').value = mat[0];
                document.getElementById('cpuField').value = mat[1];
                document.getElementById('playerSleeve').value = sleeve[0];
                document.getElementById('cpuSleeve').value = sleeve[1];
                document.getElementById('playerIcon').value = icon[0];
                document.getElementById('cpuIcon').value = icon[1];
                document.getElementById('playerIconFrame').value = icon_frame[0];
                document.getElementById('cpuIconFrame').value = icon_frame[1];
                document.getElementById('playerName').value = name[0];
                document.getElementById('cpuName').value = name[1];
                document.getElementById('bgmSelect').value = duel.bgms?.[0] || 'BGM_DUEL_NORMAL_01';
                document.getElementById('storyDeckId1').value = story_deck_id[0];
                document.getElementById('storyDeckId2').value = story_deck_id[1];
                document.getElementById('lifePoints').value = life[0];
                document.getElementById('noShuffle').value = duel.noshuffle || false;

                // Update deck lists if we have deck data
                if (duel.Deck) {
                    console.log('Loading deck data:', duel.Deck);
                    updateDeckLists(duel.Deck);
                } else {
                    console.warn('No deck data found in the loaded duel');
                }

                showMessage("Duel settings loaded successfully!", "success");
            } catch (error) {
                console.error('Error loading duel:', error);
                showMessage(`Error loading duel: ${error.message}`, "error");
            } finally {
                hideLoading();
            }
        }

        function updateDeckLists(deckData) {
            console.log('Updating deck lists with data:', deckData);
            const mainDeck = document.getElementById('mainDeck');
            const extraDeck = document.getElementById('extraDeck');
            const sideDeck = document.getElementById('sideDeck');
            
            // Clear existing deck displays
            mainDeck.innerHTML = '';
            extraDeck.innerHTML = '';
            sideDeck.innerHTML = '';

            if (!deckData || !Array.isArray(deckData)) {
                console.error('Invalid deck data structure:', deckData);
                return;
            }

            const deckIndex = currentDeckType === 'player' ? 0 : 1;
            if (!deckData[deckIndex]) {
                console.error('No deck data for index:', deckIndex);
                return;
            }

            const deck = deckData[deckIndex];
            console.log('Processing deck:', deck);

            // Count cards for the main deck
            const cardCounts = {};
            if (deck?.Main?.CardIds) {
                deck.Main.CardIds.forEach(cardId => {
                    cardCounts[cardId] = (cardCounts[cardId] || 0) + 1;
                });

                // Create unique card entries
                const uniqueCards = [...new Set(deck.Main.CardIds)];
                uniqueCards.forEach(cardId => {
                    const cardInfo = getCardInfo(cardId);
                    if (!cardInfo) {
                        console.warn('No card info found for ID:', cardId);
                        return;
                    }

                    const div = document.createElement('div');
                    div.className = 'card-item';
                    div.innerHTML = `
                        <img src="${getCardImageUrl(ydkMapping[cardId])}" alt="${cardInfo.name}">
                        <div class="card-count">x${cardCounts[cardId]}</div>
                    `;
                    div.onmouseover = () => showCardPreview(cardId);
                    div.onclick = () => removeCard(currentDeckType, 'Main', deck.Main.CardIds.indexOf(cardId));
                    mainDeck.appendChild(div);
                });
            }

            // Update extra deck
            if (deck?.Extra?.CardIds) {
                deck.Extra.CardIds.forEach((cardId, index) => {
                    const cardInfo = getCardInfo(cardId);
                    if (!cardInfo) {
                        console.warn('No card info found for ID:', cardId);
                        return;
                    }

                    const div = document.createElement('div');
                    div.className = 'card-item';
                    div.innerHTML = `<img src="${getCardImageUrl(ydkMapping[cardId])}" alt="${cardInfo.name}">`;
                    div.onmouseover = () => showCardPreview(cardId);
                    div.onclick = () => removeCard(currentDeckType, 'Extra', index);
                    extraDeck.appendChild(div);
                });
            }

            // Update side deck
            if (deck?.Side?.CardIds) {
                deck.Side.CardIds.forEach((cardId, index) => {
                    const cardInfo = getCardInfo(cardId);
                    if (!cardInfo) {
                        console.warn('No card info found for ID:', cardId);
                        return;
                    }

                    const div = document.createElement('div');
                    div.className = 'card-item';
                    div.innerHTML = `<img src="${getCardImageUrl(ydkMapping[cardId])}" alt="${cardInfo.name}">`;
                    div.onmouseover = () => showCardPreview(cardId);
                    div.onclick = () => removeCard(currentDeckType, 'Side', index);
                    sideDeck.appendChild(div);
                });
            }

            // Update counts
            document.getElementById('mainCount').textContent = `${deck?.Main?.CardIds?.length || 0} cards`;
            document.getElementById('extraCount').textContent = `${deck?.Extra?.CardIds?.length || 0} cards`;
            document.getElementById('sideCount').textContent = `${deck?.Side?.CardIds?.length || 0} cards`;
        }

        function toggleDeck(type) {
            currentDeckType = type;
            document.getElementById('playerToggle').classList.toggle('active', type === 'player');
            document.getElementById('cpuToggle').classList.toggle('active', type === 'cpu');
            
            // Update deck display with current data
            if (currentDuelJson?.res?.[0]?.[1]?.Duel?.Deck) {
                updateDeckLists(currentDuelJson.res[0][1].Duel.Deck);
            }
        }

        function searchCards() {
            const query = document.getElementById('cardSearch').value.toLowerCase();
            const resultsList = document.getElementById('searchResults');
            resultsList.innerHTML = '';

            if (query.length < 2) return;

            const searchResults = [];
            
            Object.entries(ydkMapping).forEach(([gameId, konamiId]) => {
                const cardInfo = cardDatabase[konamiId];
                if (!cardInfo) return;
                
                if (gameId.includes(query) || 
                    cardInfo.name.toLowerCase().includes(query) ||
                    konamiId.includes(query)) {
                    searchResults.push({
                        gameId: gameId,
                        cardInfo: cardInfo,
                        konamiId: konamiId
                    });
                }
            });

            if (searchResults.length === 0) {
                resultsList.innerHTML = '<div class="result-item">No cards found</div>';
                return;
            }

            searchResults.sort((a, b) => a.cardInfo.name.localeCompare(b.cardInfo.name));

            searchResults.slice(0, 50).forEach(result => {
                const div = document.createElement('div');
                div.className = 'result-item';
                div.innerHTML = `
                    <img src="${getCardImageUrl(result.cardInfo.id)}" alt="${result.cardInfo.name}">
                    <div class="result-info">
                        <div class="result-name">${result.cardInfo.name}</div>
                        <div class="result-type">${result.cardInfo.type}</div>
                    </div>
                `;
                div.onmouseover = () => showCardPreview(result.gameId);
                div.onclick = () => addCard(currentDeckType, result.gameId);
                resultsList.appendChild(div);
            });
        }

        function addCard(target, cardId) {
            if (!currentDuelJson?.res?.[0]?.[1]?.Duel?.Deck) {
                // Initialize deck structure if it doesn't exist
                currentDuelJson.res[0][1].Duel.Deck = [
                    {
                        Main: { CardIds: [], Rare: [] },
                        Extra: { CardIds: [], Rare: [] },
                        Side: { CardIds: [], Rare: [] }
                    },
                    {
                        Main: { CardIds: [], Rare: [] },
                        Extra: { CardIds: [], Rare: [] },
                        Side: { CardIds: [], Rare: [] }
                    }
                ];
            }

            const deckIndex = target === 'player' ? 0 : 1;
            const deck = currentDuelJson.res[0][1].Duel.Deck[deckIndex];

            // Initialize Main deck if it doesn't exist
            if (!deck.Main) {
                deck.Main = { CardIds: [], Rare: [] };
            }

            // Add card to deck
            deck.Main.CardIds.push(parseInt(cardId));
            deck.Main.Rare.push(1);

            // Update UI
            document.getElementById('jsonEditor').value = JSON.stringify(currentDuelJson, null, 2);
            updateDeckLists(currentDuelJson);
        }

        function removeCard(target, deckType, index) {
            if (!currentDuelJson?.res?.[0]?.[1]?.Duel?.Deck) return;

            const deckIndex = target === 'player' ? 0 : 1;
            const deck = currentDuelJson.res[0][1].Duel.Deck[deckIndex];

            if (!deck[deckType]) return;

            // Remove card
            deck[deckType].CardIds.splice(index, 1);
            deck[deckType].Rare.splice(index, 1);

            // Update UI
            document.getElementById('jsonEditor').value = JSON.stringify(currentDuelJson, null, 2);
            updateDeckLists(currentDuelJson);
        }

        function saveDuelJson() {
            try {
                const jsonText = document.getElementById('jsonEditor').value;
                const data = JSON.parse(jsonText);
                const chapterId = document.getElementById('duelJsonChapter').value;
                
                const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${chapterId}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                document.getElementById('jsonError').textContent = '';
            } catch (error) {
                document.getElementById('jsonError').textContent = `Invalid JSON: ${error.message}`;
            }
        }

        function showCardPreview(gameId) {
            const cardInfo = getCardInfo(gameId);
            if (!cardInfo) return;

            const preview = document.querySelector('.card-preview');
            if (!preview) return;

            const konamiId = ydkMapping[gameId];
            if (!konamiId) return;

            // Format ATK/DEF if they exist
            let statsText = '';
            if (cardInfo.atk !== undefined && cardInfo.def !== undefined) {
                statsText = `<div class="card-stats">ATK: ${cardInfo.atk} / DEF: ${cardInfo.def}</div>`;
            }

            // Format Level/Rank if it exists
            let levelText = '';
            if (cardInfo.level) {
                levelText = `<div class="card-level">Level: ${cardInfo.level}</div>`;
            }

            preview.innerHTML = `
                <img src="${getCardImageUrl(konamiId)}" alt="${cardInfo.name}" title="${cardInfo.name}">
                <div class="card-info">
                    <div class="card-name">${cardInfo.name}</div>
                    <div class="card-type">${cardInfo.type}${cardInfo.race ? ` / ${cardInfo.race}` : ''}</div>
                    ${levelText}
                    ${statsText}
                    <div class="card-desc">${cardInfo.desc || ''}</div>
                </div>
            `;
        }

        function getCardImageUrl(konamiId) {
            // Use high-resolution card images
            return `https://images.ygoprodeck.com/images/cards/${konamiId}.jpg`;
        }

        async function loadMovieFiles() {
            const chapters = [];
            for (const [gateId, gate] of Object.entries(soloData.res[0][1].Master.Solo.chapter)) {
                for (const [chapterId, chapter] of Object.entries(gate)) {
                    if (chapter.anime === 1) {
                        chapters.push(chapterId);
                    }
                }
            }

            for (const chapterId of chapters) {
                try {
                    const response = await fetch(`${workingDirectory}/SoloMovies/${chapterId}.json`);
                    if (!response.ok) {
                        console.warn(`Could not load movie file for chapter ${chapterId}: ${response.statusText}`);
                        continue;
                    }
                    const data = await response.json();
                    movieFiles[chapterId] = data;
                } catch (error) {
                    console.warn(`Could not load movie file for chapter ${chapterId}:`, error);
                }
            }
            updateMovieList();
            populateMovieChapterSelect();
        }

        function loadMovie() {
            const chapterId = document.getElementById('movieChapter').value;
            if (!chapterId) return;

            const movieData = movieFiles[chapterId];
            if (movieData) {
                document.getElementById('movieUrl').value = movieData.movie.url || '';
                document.getElementById('movieBv').value = movieData.movie.bv || '0.800000';
                document.getElementById('movieDs').value = movieData.movie.ds || '';
                document.getElementById('moviePt').value = movieData.movie.pt || '';
            }
        }

        function saveMovie() {
            const chapterId = document.getElementById('movieChapter').value;
            if (!chapterId) {
                alert('Please select a chapter first');
                return;
            }

            const movieData = {
                movie: {
                    remote: true,
                    url: document.getElementById('movieUrl').value,
                    bv: document.getElementById('movieBv').value,
                    ds: document.getElementById('movieDs').value,
                    pt: parseInt(document.getElementById('moviePt').value) || 0
                }
            };

            const dataStr = JSON.stringify(movieData, null, 2);
            const blob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${chapterId}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            movieFiles[chapterId] = movieData;
            updateMovieList();
        }

        function updateMovieList() {
            const movieList = document.getElementById('movieList');
            movieList.innerHTML = '';

            Object.entries(movieFiles).sort(([a], [b]) => parseInt(a) - parseInt(b)).forEach(([chapterId, data]) => {
                const movieElement = document.createElement('div');
                movieElement.className = 'gate-item';
                movieElement.innerHTML = `
                    <div>Chapter ${chapterId} Movie</div>
                    <div class="help-text">URL: ${data.movie.url}</div>
                    <div class="help-text">Duration: ${data.movie.pt}ms</div>
                    <button onclick="document.getElementById('movieChapter').value='${chapterId}';loadMovie()">Edit</button>
                `;
                movieList.appendChild(movieElement);
            });
        }

        function toggleMovieFields() {
            const isMovie = document.getElementById('isMovie').checked;
            document.getElementById('mydeckSetId').disabled = isMovie;
            document.getElementById('npcId').disabled = isMovie;
            if (isMovie) {
                document.getElementById('mydeckSetId').value = '0';
                document.getElementById('npcId').value = '0';
            }
        }

        async function loadItemData() {
            try {
                console.log('Loading ItemID.json...');
                const url = new URL('ItemID.json', workingDirectory).href;
                console.log('Fetching from URL:', url);
                
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Failed to load ItemID.json: ${response.statusText}`);
                let text = await response.text();
                
                // Clean up the JSON text:
                // 1. Remove all comments (both inline and standalone)
                text = text.replace(/\/\/[^\n]*\n/g, '\n');
                
                // 2. Remove all trailing commas in arrays and objects
                text = text.replace(/,(\s*[\]}])/g, '$1');
                
                // 3. Remove empty lines and extra whitespace
                text = text.replace(/^\s*[\r\n]/gm, '');
                text = text.trim();
                
                try {
                    console.log('Attempting to parse cleaned JSON...');
                    const rawData = JSON.parse(text);
                    
                    // Convert the data structure to a more manageable format
                    const cleanedData = {};
                    for (const [category, items] of Object.entries(rawData)) {
                        cleanedData[category] = [];
                        if (Array.isArray(items)) {
                            for (let i = 0; i < items.length; i++) {
                                const id = items[i];
                                if (typeof id === 'number') {
                                    cleanedData[category].push({
                                        id: id,
                                        name: `Item ${id}`  // Default name
                                    });
                                }
                            }
                        }
                    }
                    
                    itemData = cleanedData;
                    console.log('ItemID.json processed successfully');
                    console.log('Categories loaded:', Object.keys(itemData));
                    populateItemSelects();
                } catch (parseError) {
                    console.error('Parse error:', parseError);
                    console.log('Cleaned text that failed to parse:', text.substring(0, 500) + '...');
                    throw new Error(`Failed to parse ItemID.json: ${parseError.message}`);
                }
            } catch (error) {
                console.error('Error loading ItemID.json:', error);
                console.log('Current working directory:', workingDirectory);
                alert('Error loading ItemID.json. Some features may not work properly. Check the console for details.');
            }
        }

        function populateItemSelects() {
            if (!itemData) return;

            // Helper function to populate a select element
            function populateSelect(elementId, itemType, defaultValue = null) {
                const select = document.getElementById(elementId);
                select.innerHTML = '';
                
                // Get the array of items for the specified type
                const items = itemData[itemType];
                if (!items) {
                    console.warn(`No items found for type: ${itemType}`);
                    return;
                }

                // Sort items by ID
                items.sort((a, b) => a.id - b.id);
                
                // Add options to select
                items.forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.id;
                    option.textContent = `${item.id}`;
                    select.appendChild(option);
                    
                    // Set as selected if this is the default value
                    if (item.id === defaultValue) {
                        option.selected = true;
                    }
                });

                // If no option was selected and we have items, select the first one
                if (select.selectedIndex === -1 && items.length > 0) {
                    select.selectedIndex = 0;
                }
            }

            // Populate all select elements with their default values
            populateSelect('playerIcon', 'ICON', 1010014);
            populateSelect('cpuIcon', 'ICON', 1010001);
            populateSelect('playerIconFrame', 'ICON_FRAME', 1030001);
            populateSelect('cpuIconFrame', 'ICON_FRAME', 1030001);
            populateSelect('playerSleeve', 'PROTECTOR', 1070001);
            populateSelect('cpuSleeve', 'PROTECTOR', 1070001);
            populateSelect('playerField', 'FIELD', 1090001);
            populateSelect('cpuField', 'FIELD', 1090001);
        }

        function validateLifePoints(input) {
            const value = parseInt(input.value);
            if (value < 100) {
                input.value = 100;
                alert('Life points cannot be less than 100');
            } else if (value > 99999) {
                input.value = 99999;
                alert('Life points cannot exceed 99999');
            }
        }

        function showLoading(message = 'Loading...') {
            const loadingIndicator = document.getElementById('loadingIndicator');
            loadingIndicator.querySelector('div:last-child').textContent = message;
            loadingIndicator.style.display = 'flex';
        }

        function hideLoading() {
            document.getElementById('loadingIndicator').style.display = 'none';
        }

        function updateDuelsList() {
            const duelList = document.getElementById('duelList');
            duelList.innerHTML = '';
            
            // Add status message at the top
            const statusDiv = document.createElement('div');
            statusDiv.className = 'status-message';
            statusDiv.style.marginBottom = '15px';
            statusDiv.style.padding = '10px';
            statusDiv.style.backgroundColor = '#f8f9fa';
            statusDiv.style.borderRadius = '4px';
            duelList.appendChild(statusDiv);
            
            const chapters = [];
            let loadedCount = 0;
            
            // Collect all chapters with NPCs
            for (const [gateId, gate] of Object.entries(soloData.res[0][1].Master.Solo.chapter)) {
                for (const [chapterId, chapter] of Object.entries(gate)) {
                    if (chapter.npc_id > 0) {
                        chapters.push({
                            chapterId,
                            gateId,
                            npcId: chapter.npc_id,
                            difficulty: chapter.difficulty
                        });
                    }
                }
            }

            // Sort chapters numerically
            chapters.sort((a, b) => parseInt(a.chapterId) - parseInt(b.chapterId));
            
            // Update status message
            statusDiv.textContent = `Found ${chapters.length} chapters with duels`;
            
            // Create duel entries
            chapters.forEach(({chapterId, gateId, npcId, difficulty}) => {
                const duelElement = document.createElement('div');
                duelElement.className = 'gate-item';
                
                // Get difficulty name
                const difficultyNames = ['Story', 'Easy', 'Normal', 'Hard', 'Very Hard', 'Challenge'];
                const difficultyName = difficultyNames[difficulty] || 'Unknown';
                
                duelElement.innerHTML = `
                    <div style="margin-bottom: 5px;">
                        <strong>Chapter ${chapterId}</strong> (Gate ${gateId})
                        <div class="help-text">
                            Difficulty: ${difficultyName}
                            <br>
                            NPC ID: ${npcId}
                        </div>
                    </div>
                    <button onclick="loadDuel('${chapterId}')" style="margin-right: 5px;">Load Settings</button>
                    <button onclick="previewDuel('${chapterId}')" style="background: #17a2b8;">Preview JSON</button>
                `;
                duelList.appendChild(duelElement);
                
                // Check if duel file exists
                fetch(`${workingDirectory}/SoloDuels/${chapterId}.json`)
                    .then(response => {
                        if (response.ok) loadedCount++;
                        statusDiv.textContent = `Found ${chapters.length} chapters with duels (${loadedCount} duel files loaded)`;
                    })
                    .catch(() => {});
            });
        }

        function previewDuel(chapterId) {
            fetch(`${workingDirectory}/SoloDuels/${chapterId}.json`)
                .then(response => response.json())
                .then(data => {
                    // Switch to the Duel JSON tab
                    showSection('duelJson');
                    // Load the data into the JSON editor
                    document.getElementById('duelJsonChapter').value = chapterId;
                    document.getElementById('jsonEditor').value = JSON.stringify(data, null, 2);
                    // Update deck lists if available
                    if (data?.res?.[0]?.[1]?.Duel?.Deck) {
                        currentDuelJson = data;
                        updateDeckLists(data);
                    }
                })
                .catch(error => {
                    alert(`Error loading duel preview: ${error.message}`);
                });
        }

        function showMessage(message, type) {
            const duelList = document.getElementById('duelList');
            const messageDiv = document.createElement('div');
            messageDiv.className = type === 'success' ? 'success-message' : 'error-message';
            messageDiv.textContent = message;
            messageDiv.style.color = type === 'success' ? 'green' : 'red';
            messageDiv.style.marginTop = '10px';
            duelList.insertBefore(messageDiv, duelList.firstChild);
            setTimeout(() => messageDiv.remove(), type === 'success' ? 3000 : 5000);
        }

        // Modify the initialization to ensure proper loading order
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                console.log('Starting initialization...');
                await initializeEditor();
                console.log('Initialization complete');
            } catch (error) {
                console.error('Initialization error:', error);
                alert('Error during initialization. Please check the console for details.');
            }
        });

        function loadDuelJson() {
            const chapterId = document.getElementById('duelJsonChapter').value;
            if (!chapterId) return;

            fetch(`${workingDirectory}/SoloDuels/${chapterId}.json`)
                .then(response => response.json())
                .then(data => {
                    currentDuelJson = data;
                    document.getElementById('jsonEditor').value = JSON.stringify(data, null, 2);
                    
                    // Update deck lists if available
                    if (data?.res?.[0]?.[1]?.Duel?.Deck) {
                        updateDeckLists(data.res[0][1].Duel.Deck);
                    } else {
                        console.warn('No deck data found in the loaded duel');
                        // Clear deck displays
                        updateDeckLists([
                            {
                                Main: { CardIds: [], Rare: [] },
                                Extra: { CardIds: [], Rare: [] },
                                Side: { CardIds: [], Rare: [] }
                            },
                            {
                                Main: { CardIds: [], Rare: [] },
                                Extra: { CardIds: [], Rare: [] },
                                Side: { CardIds: [], Rare: [] }
                            }
                        ]);
                    }
                })
                .catch(error => {
                    console.error('Error loading duel JSON:', error);
                    document.getElementById('jsonError').textContent = `Error loading duel: ${error.message}`;
                });
        }
    </script>
</body>
</html> 